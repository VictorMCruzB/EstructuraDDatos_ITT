using System;  // using System;
using System.Collections.Generic;  // using System.Collections.Generic; 
using System.Linq;  // using System.Linq;
using System.Text;  // using System.Text;
using System.Threading.Tasks;  // using System.Threading.Tasks;
// Espacio entre código;
namespace E_4_3.CruzBetancourtVictorManuel  // Nombre de la práctica;
{  // Se abre la llave;
    class Algoritmo  // Se crea la clase Algoritmo;
    {  // Se abre la llave;
        public Func<T, IEnumerable<T>> CamiMasCortFunc<T>(Grafo<T> grafo, T start)  //  Se declara un método público que lleva por nombre CamiMasCort;
        {  // Se abre la llave;
            var Anterior = new Dictionary<T, T>();  // Se declara una nueva variable de tipo var que lleva por nombre Anterior, en la cual se inicializa una nueva instancia de la clase Dictionary;
            // Espacio entre código;
            var queue = new Queue<T>();  // Se declara una nueva variable de tipo var que lleva por nombre queue, en la cual se inicializa una nueva instancia de la clase Queue;
            queue.Enqueue(start);  // Se le agrega a queue el arámetro start;
            // Espacio entre código;
            while (queue.Count > 0)  // Se declara un ciclo while como pone como condición si el número de elementos contenidos en queue es mayor a 0;
            {  // Se abre la llave;
                var vert = queue.Dequeue();  // Se declara una nueva variable de tipo var que lleva por nombre vert, en la cual se quita el valor contenido en queue;
                foreach (var Vecino in grafo.ListAd[vert])  // Se declara un ciclo foreach, el cual indica que cada uno de los valores de la variable de tipos var que lleva por nombre Vecino pasan a ser valores grafo.ListAd[vert];
                {  // Se abre la llave;
                    if (Anterior.ContainsKey(Vecino))  // Se declara un ciclo if que pone como condición si la variable Anterior contiene a Vecino, hacer...;
                        continue;  // Continúa :);
                    // Espacio entre código;
                    Anterior[Vecino] = vert;  // La variable Anterior[Vecino] toma el valor contenido en la variable vert;
                    queue.Enqueue(Vecino);  // Vecino es ingresado a queue;
                }  // Se cierra la llave;
            }  // Se cierra la llave;
            // Espacio entre código;
            Func<T, IEnumerable<T>> CamiMasCort = v =>  // Se declara un nuevo método que lleva por nombre CamiMasCort;
            {  // Se abre la llave;
                var Camino = new List<T> { };  // Se declara una nueva variable de tipo var que lleva por nombre Camino y de paso se inicializa una nueva instancia de la clase List;
                // Espacio entre código;
                var Actual = v;  // Se declara una nueva variable de tipo var que lleva por nombre Actual y toma el valor de la variable v;
                while (!Actual.Equals(start))  // Se declara un ciclo while, en el cual se establece la condición de que mientras sea diferente de Actual.Equals(start) hacer...;
                {  // Se abre la llave;
                    Camino.Add(Actual);  // Se añade la variable Actual a la lista Camino;
                    Actual = Anterior[Actual];  // La variable Actual toma como valor Anterior[Actual]; 
                };  // Se cierra la llave;
                // Espacio entre código;
                Camino.Add(start);  // Se añade la variable start a la lista Camino; 
                Camino.Reverse();  // Se invierte la lista;
                // Espacio entre código;
                return Camino;  // Regresa el valor contenido en Camino;
            };  // Se cierra la llave;
            // Espacio entre código;
            return CamiMasCort;  // Regresa el valor contenido en CamiMasCort;
        }  // Se cierra la llave;
        // Espacio entre código;
        public HashSet<T> BFS<T>(Grafo<T> grafo, T start)  // Se declara un nuevo método que lleva por nombre BFS;
        {  // Se abre la llave;
            var Visit = new HashSet<T>();  // Se declara una nueva variable de tipo var que lleva por nombre Visit y de paso se inicializa una nueva instancia de la clase HashSet;
            // Espacio entre código;
            if (!grafo.ListAd.ContainsKey(start))  // Se declara un if en el cual se establece como condición que si es diferente de grafo.ListAd.ContainsKey(start) hacer...; 
                return Visit;  // Regresa el valor contenido en Visit;
            // Espacio entre código;
            var queue = new Queue<T>();  // Se declara una nueva variable de tipo var que lleva por nombre queue y se inicializa una nueva instancia de la clase Queue;
            queue.Enqueue(start);  // Se agrega start a queue;
            // Espacio entre código;
            while (queue.Count > 0)  // Se declara un ciclo while que indica que mientras que el número de elementos contenidos en queue sea mayor que 0 hacer...;
            {  // Se abre la llave;
                var Vert = queue.Dequeue();  // Se declara una nueva variable de tipo var que lleva por nombre Vert y se le da el valor de lo que había en queue;
                // Espacio entre código;
                if (Visit.Contains(Vert))  // Se declara un nuevo ciclo if que pone como condición que si Visit contiene el valor de Vert hacer...;
                    continue;  // Continúa...;
                // Espacio entre código;
                Visit.Add(Vert);  // Se añade Vert a Visit;
                // Espacio entre código;
                foreach (var Vecino in grafo.ListAd[Vert])  // Se declara un ciclo foreach que indica que cada uno de los valores de Vecino pasa a la lista de adyacencia;
                    if (!Visit.Contains(Vecino))  // Se declara un ciclo if que indica que si es distinto de Visit.Contains(Vecino) hacer...;
                        queue.Enqueue(Vecino);  // Vecino es agregado a queue;
            }  // Se cierra la llave;
            // Espacio entre código;
            return Visit;  // Retorna el valor contenido en la variable Visit;
        }  // Se cierra la llave;
    }  // Se cierra la llave;
}  // Se cierra la llave;
